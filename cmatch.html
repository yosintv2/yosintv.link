<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cricket Match Extractor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom animation for popups */
        @keyframes fadeInOut {
            0% { opacity: 0; transform: translateY(-10px); }
            10% { opacity: 1; transform: translateY(0); }
            90% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-10px); }
        }
        .popup {
            animation: fadeInOut 2s ease-in-out forwards;
        }
    </style>
</head>
<body class="font-sans max-w-2xl mx-auto p-5 bg-gray-50">
    <h1 class="text-3xl font-bold mb-4 text-center text-gray-800">Cricket Match Extractor</h1>
    <p class="mb-4 text-center text-gray-600">Paste your raw match data below and click "Extract" to get a clean list of matches, dates, and times.</p>
    
    <div class="relative w-full h-[600px] mb-4">
        <textarea id="inputData" class="w-full h-full p-4 border border-gray-300 rounded-lg shadow-inner resize-none focus:outline-none focus:ring-2 focus:ring-blue-500 transition-all duration-200" placeholder="Paste your match data here..."> SUN, AUG 31 2025
Eastern Europe Cup 2025
Croatia vs Serbia, 6th Match
GB Oval, Szodliget
4:00 PM
07:00 AM GMT / 09:00 AM LOCAL

</textarea>
    </div>

    <div class="fixed right-5 top-1/2 -translate-y-1/2 flex flex-col space-y-2 z-10">
        <button onclick="extractMatches()" class="px-6 py-3 bg-blue-600 text-white font-semibold rounded-full shadow-lg hover:bg-blue-700 transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2">Extract</button>
        <button onclick="copyMatches()" class="px-6 py-3 bg-green-600 text-white font-semibold rounded-full shadow-lg hover:bg-green-700 transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2">Copy</button>
    </div>
    
    <div id="output" class="min-h-[100px] mt-5 p-6 border border-gray-300 bg-white rounded-lg shadow-md text-gray-800">
        <p class="text-gray-500 italic">Extracted matches will appear here...</p>
    </div>

    <div id="extractNotification" class="hidden fixed bottom-8 left-1/2 transform -translate-x-1/2 bg-blue-500 text-white px-4 py-2 rounded-md shadow-md popup">Extracted!</div>
    <div id="copyNotification" class="hidden fixed bottom-8 left-1/2 transform -translate-x-1/2 bg-green-500 text-white px-4 py-2 rounded-md shadow-md popup">Copied to clipboard!</div>

    <script>
        function extractMatches() {
            const input = document.getElementById('inputData').value;
            const output = document.getElementById('output');
            const extractNotification = document.getElementById('extractNotification');
            
            // Regex to find all match blocks. A block starts with a line containing 'vs' and ends before the next one.
            const matchRegex = /([A-Za-z\s]+ vs [A-Za-z\s]+(?:,.*?\n)?)(.*?)(?=^[A-Za-z\s]+ vs [A-Za-z\s]+|^\n$)/gms;
            
            let result = '';
            let currentDate = 'Date not found';
            let matchesByDate = {};
            
            // Helper function to convert 12-hour time to 24-hour format
            function convertTo24Hour(timeStr) {
                const [time, period] = timeStr.split(/(AM|PM)/).filter(Boolean);
                let [hours, minutes] = time.split(':').map(Number);
                if (period.toUpperCase() === 'PM' && hours !== 12) hours += 12;
                if (period.toUpperCase() === 'AM' && hours === 12) hours = 0;
                return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
            }

            // Helper function to extract month and day from a full date string
            function formatDate(dateStr) {
                const match = dateStr.match(/[A-Z]{3},\s*([A-Z]{3}\s*\d{1,2})\s*202[3-7]/);
                return match ? match[1] : dateStr;
            }

            // Split by explicit date headers first
            const dateBlocks = input.split(/([A-Z]{3},\s*[A-Z]{3}\s*\d{1,2}\s*202[3-7])/).filter(block => block.trim());

            dateBlocks.forEach((block, index) => {
                // If it's a date header, set the current date.
                if (block.match(/^[A-Z]{3},\s*[A-Z]{3}\s*\d{1,2}\s*202[3-7]/)) {
                    currentDate = formatDate(block.trim());
                    matchesByDate[currentDate] = [];
                } else {
                    // It's a block of matches. Process line by line.
                    const lines = block.split('\n').map(line => line.trim()).filter(line => line);
                    let currentMatchName = null;
                    
                    lines.forEach(line => {
                        // Look for a line containing "vs"
                        if (line.includes(' vs ')) {
                            currentMatchName = line;
                            // Check if the match name has a date suffix like (Sep 01)
                            const dateMatch = line.match(/\((.*?)\)/);
                            if (dateMatch) {
                                // Update the date for this specific match
                                const newDate = formatDate(dateMatch[1]);
                                if (matchesByDate[newDate]) {
                                    currentDate = newDate;
                                }
                                currentMatchName = line.replace(/\(.*\)/, '').trim();
                            }
                        }
                        // Look for a line with AM/PM but not GMT or LOCAL
                        if ((line.includes('AM') || line.includes('PM')) && !line.includes('GMT') && !line.includes('LOCAL')) {
                            const time = convertTo24Hour(line.replace(/\(.*?\)/, '').trim());
                            if (currentMatchName && time) {
                                if (!matchesByDate[currentDate]) {
                                    matchesByDate[currentDate] = [];
                                }
                                matchesByDate[currentDate].push({ time, matchName: currentMatchName });
                                currentMatchName = null; // Reset for the next match
                            }
                        }
                    });
                }
            });
            
            // Format the final output as plain text inside a <pre> tag
            let outputText = '';
            for (const date in matchesByDate) {
                if (matchesByDate[date].length > 0) {
                    outputText += `${date}\n\n`;
                    matchesByDate[date].forEach(match => {
                        outputText += `${match.time}\n${match.matchName}\n\n`;
                    });
                }
            }

            output.innerHTML = `<pre class="text-gray-800">${outputText || 'No valid matches found.'}</pre>`;

            // Show extract notification
            extractNotification.classList.remove('hidden');
            setTimeout(() => {
                extractNotification.classList.add('hidden');
            }, 2000);
            output.scrollIntoView({ behavior: 'smooth', block: 'start' }); 
        }

        function copyMatches() {
            const output = document.getElementById('output');
            const copyNotification = document.getElementById('copyNotification');
            // Get all match paragraphs
            const textToCopy = output.textContent;
            
            // Copy to clipboard
            navigator.clipboard.writeText(textToCopy.trim()).then(() => {
                copyNotification.classList.remove('hidden');
                setTimeout(() => {
                    copyNotification.classList.add('hidden');
                }, 2000);
            }).catch(err => {
                console.error('Failed to copy matches:', err);
            });
        }
    </script>
</body>
</html>
